# 📚 실전 카프카: 개발부터 운영까지 정리

## 1. 챕터/섹션 요약

**주요 내용:**

### 잘란도와 트위터의 카프카 도입 사례

- 잘란도: 다양한 데이터 요구사항을 근본적으로 해결하기 위한 대첵이 필요. -> 이벤트 드리븐 시스템으로의 전환을 결정
  - 이벤트 드리븐: 인바운드 데이터와 아웃바운드 데이터가 일치해야함 -> 데이터 검증의 피로
  - Rest API 통신: 동기화 방식으로 인한 한계점 발생 (변경된 데이터 올바른 전달, 순서 보장, 다양한 클라이언트들의 요구사항 지원의 어려움 등)
  - 동기 -> 비동기 방식 전환:
- 카프카의 장점
  - 빠른 데이터 수집이 가능함
  - 순서가 보장되어 있음. -> 유효성 검사나 동시 수정 같은 복잡성이 제거됨
  - 적어도 한번 전송 방식 -> 프로듀서가 재전송을 하더라도 데이터 변화는 일어나지 않음 (멱등성)
  - 자연스러운 백프레셔 핸들링 -> 카프카의 클라이언트는 폴 방식으로 동작함으로 자기 자신의 속도로 데이터 처리 가능
  - 강력한 파티셔닝 -> 효과적인 수평확장
- 트위터: 실시간 서비스 -> 실시간 요구사항을 처리해야 함 -> 카프카 전환 결정
  - 비용 절감: 카프카는 BPS와 상관없이 지연이 거의 발생하지 않음 (하나의 프로세스에서 스토리지와 요청을 모두 처리)
  - OS 의존: 백그라운드로 fsync()를 처리하고 제로카피를 사용함
  - 강력한 커뮤니티: 사용자가 많고 대중화 되어있기 때문에 관련 엔지니어 찾기도 편함
- 카프카를 사용하기 위해 고민해야 할 것
  - 동기/비동기 데이터 전송에 대한 고민이 있나?
  - 실시간 데이터 처리에 대한 고민이 있나?
  - 현재의 데이터 처리에 한계를 느끼나?
  - 새로운 데이터 파이프 라인이 복잡하다고 생각하나?
  - 데이터 처리의 비용 절감을 고려하고 있나?

### 카프카의 주요 특징

1. 높은 처리량과 낮은 지연시간

- 카프카, 펄사, 래빗MQ의 성능을 비교했을 때 처리량이 가장 높은것 카프카, 가장 빠른 것은 래빗MQ이나, 처리량과 응답 속도를 같이 비교했을 때 카프카 1등

2. 높은 확장성
3. 고가용성

- 클러스터 내 리플리케이션 기능 추가

4. 내구성

- 카프카로 전송되는 모든 매시지는 안전한 저장소인 카프카의 로컬 디스크에 저장됨. 카프카의 경우에는 컨슈머가 메시지를 가져가더라도 메시지는 삭제되지 않고 지정된 설정 시간 또는 로그의 크기만큼 로컬 디스크에 보관되므로 코드의 버그나 장애가 발생하더라도 과거의 메시지들을 불러와 재처리할 수 있음

5. 개발 편의성

- 카프카는 메시지를 전송하는 역할을 하는 프로듀서와 메시지를 가져오는 역할을 하는 컨슈머가 완벽하게 분리되어 동작하고 서로 영향을 주지 않는다.
- 카프카 커넥트, 스키마 레지스트리 등을 제공함

6. 운영 및 관리 편의성

### 카프카의 사용 사례

1. 데이터 파이프라인: 넷플릭스
![kafka](https://github.com/user-attachments/assets/eb9ebb5b-0502-48a5-92a6-7689451f8435)

- 데이터를 수집, 통계, 처리, 적재하기 위해 파이프라인들이 연결되어 있고 이런 파이프라인을 연결해주는 역할로 카프카를 사용중

2. 데이터 통합: 우버
![kafka_uber](https://github.com/user-attachments/assets/55ea6f05-8cbf-47f3-833f-e5e3acf51548)

- 운전자와 탑승자 앱으로부터 이벤트 데이터를 수집, 수집된 데이터는 카프카를 통해 다운스트림 컨슈머들에게 전달, 카프카가 애플리케이션 분석, 디버깅, 알람등으로 이용됨

이외에도 머신러닝, 스마트시티 등등에 사용된다

## 2. 핵심 개념/용어 정리

- **용어:**
  - 백프레셔: **생산자(Producer)**가 데이터를 너무 빨리 보내서, **소비자(Consumer)**가 그 속도를 따라가지 못할 때 생기는 압력
  - 메시징 시스템: 서로 다른 애플리케이션/서비스가 메시지(데이터)를 주고받을 수 있게 중간에서 도와주는 시스템

## 3. 코드/예제

예시: 주문 시스템

- 유저가 주문함 → REST API로 요청
- 주문 요청을 처리함 → Kafka로 주문 메시지 전송
- 다른 마이크로서비스들(결제, 배송)이 Kafka 메시지를 비동기로 소비함

**[Client] --(REST API)--> [주문 API] --(Kafka)--> [결제] / [배송] / [재고]**

## 4. 느낀점 & 질문

카프카는 엄청난 친구구나!
